папка public содержит все статичные данные
eslint уже не надо настраивать, он встроен в CRA. но при этом jshint все равно надо отключать.

babel занимается не только тем, что делает код понятным для многих браузеров, в которых некоторые функции ещё не доступны,
но и переводит jsx формат в обычный jshint
https://babeljs.io/docs/en/babel-plugin-transform-react-jsx


________________________________
Свойства компонентов - или пропсы

пропс мы используем в компонентах, но никогда не записываем что-то внутри него. компонент не должен менять свои пропсы. чтобы изменить элемент в компоненте, надо полностью перерендерить компонент
Называть свойства стоит так, чтобы они лучше всего подходили к содержимому компонента

//function WhoAmI(props){//props все равно будет сформирован, если даже его не прописать
function WhoAmI({name, surname, link}){//чаще пишут так - деструктуризация
    return (
        <div>
            <h1>My name is {name()}, surname - {surname}</h1>
            <a href={link}>My profile</a>
        </div>
    )
}

В значение свойства можно писать строку, функцию, объект
<WhoAmI name={{firstName: 'Liza'}} surname="Golubeva" link="https://yandex.ru/"/>
<WhoAmI name={() => {return 'Seva'}} surname="NeGolubeva" link="https://yandex.ru/"/>
и вызывать 
<h1>My name is {name.firstName}, surname - {surname}</h1>
<h1>My name is {name()}, surname - {surname}</h1>



!!!Об ошибке index.js:1 Warning: Each child in a list should have a unique "key" prop.

Если есть куча элементов (несколько сотен) и нужно убрать что-то в середине, то как поменять нормально DOM структуру?
Алгоритм согласования: сравнивает старые и новые копии dom дерева
Если меняется корневой элемент (тег), то всё сносится внутри: полное перестроение dom дерева
Если в корневом элементе меняется не тег, а пропсы, дата атрибуты, классы - реакт обновляет только изменившиеся элементы

Дальше алгоритм пойдет рекурсивно по всем дочерним элементам и проверять на отличия.
Реакт сохраняет копию предыдущего дерева элементов и компонентов, сохраняет новое дерево, которое надо построить
Потом идет сравнение каждого элемента в этих двух копиях. Если есть отличия, то измененные элементы будут создавать перерисовку этого элемента
в DOM дереве. Реакт изменит в реальном DOM только то, что реально изменилось.
Но есть проблема с одинаковыми элементами. Если идет список одинаковых сотрудников, то как алгоритм поймет, что сотрудник изменился.
Сравнение идет по порядку. Если что-то возникнет в конце списка, то реакт просто добавит. А если в начале? Реакт будет думать, что весь список поменялся, потому что видит первым элемент
какой то новый, а вторым тот, кто был первым (то есть типо был элемент после него идущий, а стал этот - значит произошло изменение)

Нужно что-то, что будет говорить реакту, что это тот же элемент или компонент. id. 
Атрибут key. см в app.js. key должны быть уникальными среди соседей, а не по всему документу
key - только в контексте списков.
Это нужно всё для оптимизации скорости работы приложения. Тк всё перезаписываться будет, а не меняться только то, что нужно.
Так что этот атрибут нужен только для быстрой скорости приложения.




!!!Состояние компонентов
Есть компонент счетчик: у него есть что-то, что динамически меняется (цифра, например). Надо ее отследить.
Слайдер: есть слайд, который меняется. Но массив слайдов самих, скорость переключения - это статичные параметры.
Количество слайдов можно передать как свойство. А активный слайд - вещь динамическая.

Если есть несколько таких одинаковых компонентов.
Динамическая вещь внутри компонента - состояние компонента. Свойства статичны, а состояние динамично.
Раньше задать состояние в функциональных компонентах было невозможно.

Выводы 
1) у компонента может быть внутреннее состояние, которое может динамически меняться
2) есть как у классовых, так и у функциональных компонентов
3) state напрямую менять нельзя - только через setState
4) setState - асинхронная операция, поэтому если нужно предыдущее состояние, то надо передавать в setState callback функцию
Для того, чтобы сразу что-то вернуть, каллбэк функция оборачивается в круглые скобки, внутри которых будет возвращаться новый объект
5) в команде setState меняются только те свойства, которые мы туда прописали - остальные не меняются





!!!Обработчики события
Записываются в формате camelCase в качестве аргумента, например 
<button onClick={this.nextYear}>{this.state.text}</button>

В реакте onchange и oninput работают одинаково и чаще пишуту первый вариант (в нативном js onchange срабатывает, когда уводится фокус от элемента, а oninput сразу после изменения value)

addeventlistener вызывать нигде не нужно. 

Используем в классах стрелочные функции при создании методов - всё из-за контекста вызова this
В обработчике события при вызове метода мы используем this для указания экземпляра классах
<button onClick={this.nextYear}>{this.state.text}</button>
То же самое для пропсов и стейтов - this - экземпляр класса, чтобы функции работали только в пределах экземпляра

При срабатывании обработчика события контекст вызова теряется. Из-за того что функция вызывается внутри другого метода.
Если переработать формат метода в обычный
nextYear(){
    this.setState...
}
то выведет ошибка - this становится undefinded.

1 способ - в конструкторе прописать

this.nextYear = this.nextYear.bind(this);
слева свойства у экземпляра, справа обращаемся к методу и привязываем к конкретному экземпляру класса, чтобы ты не терял this

2 способ - стрелочные функции, как мы и делали

3 способ - анонимная стрелочная функция

commitInputChanges(e){
    this.setState({
        position: e.target.value
    })
}
<button onClick={() => {this.commitInputChanges}}>{this.state.text}</button>
вызовится функция () => {this.commitInputChanges}, внутри которой this.commitInputChanges
this стрелочная функция берет у своего родителя, поэтому в this.commitInputChanges попадет ссылка на экземпляр класса

но с точки зрения оптимизации не очень: см видео 96 14 минута


Использование аргумента в обрабтотчике
<input type="text" onChange={(e) => {this.commitInputChanges(e, 'some color')}} />
ну и в методе добавить ещё один аргумент commitInputChanges = (e, color) => {...}
ОБЯЗАТЕЛЬНО с вызовом                                         !!





!!!Фрагменты

По правилам jsx мы при return какого-то элемента должны были использовать обязательно одного общего родителя - div.
Но бывает так, что он не нужен, не содержит каких-то стилей и ломает верстку. Тогда на помощь приходят фрагменты.

___1 способ:
Они импортируются из реакт:
import {Fragment} from 'react';

и подставляются туда, как если бы мы элементы оборачивали в div

<Fragment>
    верстка...
</Fragment>


___2 способ:
просто вместо div прописать пустой тег (без импорта)

<>
    верстка...
</>





!!!Стили в реакт

___inline style: прописывается style={{fontSize: 40}} - объект со стилями, свойства стилей тоже в формате camelCase
при отсутствии единицы измерения, реакт подставляет px, поэтому их можно не указывать.
если в значении свойства не просто число, а с единицой измерения, то в формат строки
style={{fontSize: '40em', color: 'red'}}
вендерные префиксы в inline style не переводятся. их надо указывать вручную.

___css и sass:
чтобы импортировать scss файлы (это делается так же, как с css), необходимо установить
модуль sass. !!!__npm i sass --save__!!!
если создать 1 глобальный sass файл и туда импортнуть файл с переменными, и потом где-то в другом месте обратиться к переменным,
то мы получим ошибку. надо в каждый отдельный файл импортировать глобальный. 
@import '../../variables.scss';

___динамические стили и классы:
динамический класс - в employees-list-item подставляли нужный класс в зависимости от параметра increase и rise

___css in js:
styled components.
надо установить в проект: https://styled-components.com/
npm install --save styled-components
теперь можно задавать стили прямо в js файле, чтобы все было под рукой.
всегда импортировать туда, где будем использовать.
import styled from 'styled-components';

const Wrapper = styled.div`
    width: 600px;
    margin: 80px auto 0 auto;
`;
оборачивает элемент
<Wrapper>
    ...
</Wrapper>
назначает рандомное название класса (можно увидеть в консоли разработчика)

const EmpItem = styled.div`
    padding: 20px;
    mb: 15px;
    border-radius: 5px;
`;
- обертка элемента

const Header = styled.h2`
    font-size: 20px;
`;
- или подставляем туда, где бы прописывали <h2></h2>

у этих компонентов также можно использовать атрибуты (пропсы)

можно создать файл с такими компонентами и импортировать их в других файлах. так делают с кнопками, заголовками и теперь
export const Header = styled.h2`
    font-size: 20px;
`;
import {Header} from './App';

_____Наследование стилей от другого компонента
import styled from 'styled-components';
import {Header} from './App';

const BigButton = styled(Button)`
    margin: 0 auto;
    width: 245px;
`;
добавили свойства к имеющейся button.

Если мы хотим использовать кнопку, но под другим тегом (не button, а div), то делаем так
<BigButton as="div">+++</BigButton>

внутри таких компонентов можно прописывать стили вложенных тегов, чтобы не создавать для них новый компонент
const BigButton = styled(Button)`
    margin: 0 auto;
    width: 245px;
    a{
        text-decoration: undefinded;
    }
    span{
        ...
    }
`;

можно использовать пропсы и передавать их в стили.
<BigButton as="div" active>+++</BigButton>
const BigButton = styled(Button)`
    margin: 0 auto;
    width: 245px;
    color: ${props => props.active ? 'orange' : 'white'};
    ...
`;

вендерные префиксы ставятся автоматически.
псевдоэлементы так же работают.





___библиотеки компонентов в реакт со стилями:
https://react-bootstrap.github.io/
npm install react-bootstrap@next bootstrap@5.1.1 --save

import {Container, Row, Col} from 'react-bootstrap';

const Bootstrap = () => {
    return(
        <Container>
            <Row>
                <Col>1 of 2</Col>
                <Col>2 of 2</Col>
            </Row>
            <Row>
                <Col>1 of 3</Col>
                <Col>2 of 3</Col>
                <Col>3 of 3</Col>
            </Row>
        </Container>
    )
}
export default Bootstrap;

в другом файле import Bootstrap from './Bootstrap';

https://mui.com/getting-started/usage/




___ПОЛЯ КЛАССОВ И СТАТИК
в классе можно не использовать конструктор, а сразу прописывать state с значениями.

вспомним Math.random(). применялся метод не к экземпляру класса, а ко всему классу Math. Это можно сделать, если перед методом класса поставить static
Так можно сделать не только с методом, но и с переменной.
Они называются статическими методами и свойствами.

static fucntionSome =() => {
    ...
}
static logged = "on";

методы можно использовать для создания своей мини библиотеки. Свойства - когда для всех экземпляров используется какая-то переменная с конкретным значением.