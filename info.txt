папка public содержит все статичные данные
eslint уже не надо настраивать, он встроен в CRA. но при этом jshint все равно надо отключать.

babel занимается не только тем, что делает код понятным для многих браузеров, в которых некоторые функции ещё не доступны,
но и переводит jsx формат в обычный jshint
https://babeljs.io/docs/en/babel-plugin-transform-react-jsx


________________________________
Свойства компонентов - или пропсы

пропс мы используем в компонентах, но никогда не записываем что-то внутри него. компонент не должен менять свои пропсы. чтобы изменить элемент в компоненте, надо полностью перерендерить компонент
Называть свойства стоит так, чтобы они лучше всего подходили к содержимому компонента

//function WhoAmI(props){//props все равно будет сформирован, если даже его не прописать
function WhoAmI({name, surname, link}){//чаще пишут так - деструктуризация
    return (
        <div>
            <h1>My name is {name()}, surname - {surname}</h1>
            <a href={link}>My profile</a>
        </div>
    )
}

В значение свойства можно писать строку, функцию, объект
<WhoAmI name={{firstName: 'Liza'}} surname="Golubeva" link="https://yandex.ru/"/>
<WhoAmI name={() => {return 'Seva'}} surname="NeGolubeva" link="https://yandex.ru/"/>
и вызывать 
<h1>My name is {name.firstName}, surname - {surname}</h1>
<h1>My name is {name()}, surname - {surname}</h1>



!!!Об ошибке index.js:1 Warning: Each child in a list should have a unique "key" prop.

Если есть куча элементов (несколько сотен) и нужно убрать что-то в середине, то как поменять нормально DOM структуру?
Алгоритм согласования: сравнивает старые и новые копии dom дерева
Если меняется корневой элемент (тег), то всё сносится внутри: полное перестроение dom дерева
Если в корневом элементе меняется не тег, а пропсы, дата атрибуты, классы - реакт обновляет только изменившиеся элементы

Дальше алгоритм пойдет рекурсивно по всем дочерним элементам и проверять на отличия.
Реакт сохраняет копию предыдущего дерева элементов и компонентов, сохраняет новое дерево, которое надо построить
Потом идет сравнение каждого элемента в этих двух копиях. Если есть отличия, то измененные элементы будут создавать перерисовку этого элемента
в DOM дереве. Реакт изменит в реальном DOM только то, что реально изменилось.
Но есть проблема с одинаковыми элементами. Если идет список одинаковых сотрудников, то как алгоритм поймет, что сотрудник изменился.
Сравнение идет по порядку. Если что-то возникнет в конце списка, то реакт просто добавит. А если в начале? Реакт будет думать, что весь список поменялся, потому что видит первым элемент
какой то новый, а вторым тот, кто был первым (то есть типо был элемент после него идущий, а стал этот - значит произошло изменение)

Нужно что-то, что будет говорить реакту, что это тот же элемент или компонент. id. 
Атрибут key. см в app.js. key должны быть уникальными среди соседей, а не по всему документу
key - только в контексте списков.
Это нужно всё для оптимизации скорости работы приложения. Тк всё перезаписываться будет, а не меняться только то, что нужно.
Так что этот атрибут нужен только для быстрой скорости приложения.




!!!Состояние компонентов
Есть компонент счетчик: у него есть что-то, что динамически меняется (цифра, например). Надо ее отследить.
Слайдер: есть слайд, который меняется. Но массив слайдов самих, скорость переключения - это статичные параметры.
Количество слайдов можно передать как свойство. А активный слайд - вещь динамическая.

Если есть несколько таких одинаковых компонентов.
Динамическая вещь внутри компонента - состояние компонента. Свойства статичны, а состояние динамично.
Раньше задать состояние в функциональных компонентах было невозможно.

Выводы 
1) у компонента может быть внутреннее состояние, которое может динамически меняться
2) есть как у классовых, так и у функциональных компонентов
3) state напрямую менять нельзя - только через setState
4) setState - асинхронная операция, поэтому если нужно предыдущее состояние, то надо передавать в setState callback функцию
Для того, чтобы сразу что-то вернуть, каллбэк функция оборачивается в круглые скобки, внутри которых будет возвращаться новый объект
5) в команде setState меняются только те свойства, которые мы туда прописали - остальные не меняются
